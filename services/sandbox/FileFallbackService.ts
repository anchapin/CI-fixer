import { SandboxEnvironment } from '../../sandbox';
import { AppConfig } from '../../types';

export class FileFallbackService {

    /**
     * Generates a safe placeholder file.
     */
    async generatePlaceholder(config: AppConfig, filename: string, sandbox: SandboxEnvironment): Promise<void> {
        let content = '# Placeholder generated by CI-Fixer\n';
        
        if (filename.endsWith('.json')) {
            content = '{}\n';
        } else if (filename.endsWith('.js') || filename.endsWith('.ts')) {
            content = '// Placeholder generated by CI-Fixer\nexport {};\n';
        }

        try {
            await sandbox.writeFile(filename, content);
        } catch (e) {
            // Silently fail
        }
    }

    /**
     * Identifies if a reference to a missing file is likely stale.
     */
    async isReferenceStale(config: AppConfig, filename: string, referencingContent: string): Promise<boolean> {
        // Heuristic: If the file is referenced in a 'RUN' command but is missing, 
        // and we've already done an exhaustive search, it might be stale.
        const escapedFilename = filename.replace(/[.*+?^${}()|[\\]/g, '\\$&');
        const regex = new RegExp(`RUN.*${escapedFilename}`, 'm');
        return regex.test(referencingContent);
    }

    /**
     * Proposes removal of a line containing a reference to a missing file.
     */
    async proposeReferenceRemoval(config: AppConfig, filename: string, referencingContent: string): Promise<string> {
        const lines = referencingContent.split('\n');
        const escapedFilename = filename.replace(/[.*+?^${}()|[\\]/g, '\\$&');
        const regex = new RegExp(escapedFilename);
        
        return lines.filter(line => !regex.test(line)).join('\n');
    }
}
